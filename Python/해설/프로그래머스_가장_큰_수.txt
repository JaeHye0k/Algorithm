numbers라는 정수형 리스트가 주어졌을 때 배열의 원소끼리 조합하여 가장 큰 수를 만드는 문제입니다.


1. 처음에 가장 단순하게 생각해볼 수 있는 건 numbers를 내림차순으로 정렬해서 정렬한 배열을 합친 결과를 출력하는 것입니다. 하지만 그럴 경우 [6, 10, 2] 라는 리스트가 있을 때 결과로 1062가 나옵니다. 하지만 실제로 가장 큰 조합은 6210입니다.

2. 그렇다면 리스트의 각 원소를 문자열로 변환하여 정렬해보는 방법을 생각해볼 수 있습니다. 문자열 배열을 정렬할 때는 각 문자열의 문자를 아스키코드로 변환하여 대소관계를 비교합니다. [6, 10, 2]라는 리스트가 있을 때 내림차순으로 정렬을 수행하면 각 문자열의 첫 번째 문자부터 비교합니다. 그러면 6과 1과 2의 아스키코드가 비교되고 6이 가장 크고, 2가 그 다음 그리고 1이 마지막이기 때문에 [6, 2, 10]으로 정렬됩니다. 만약 비교하려는 문자가 동일한 경우는 어떨까요? [6, 65]라는 리스트가 있을 때를 가정해봅시다.
첫 번째 문자를 비교하여 6과 6이 비교되고 두 문자는 동일한 아스키코드를 가지므로 값이 동일합니다. 값이 동일할 경우에는 다음 문자를 비교합니다. 6은 두 번째 문자가 없고, 60의 두번 째 문자는 0입니다. 따라서 0이 더 크다고 판단되어 해당 리스트는 [65, 6]으로 정렬됩니다. 그럼 결과는 665이 아니라 656이 나오므로 틀린 결과가 나옵니다. 

3. 해결책은 모든 문자열의 자릿수를 맞춰주는 것입니다. 우리는 [65, 6]이라는 두 원소가 있을 때 665가 가장 큰 수의 조합이라는 것을 직감적으로 알 수 있지만 컴퓨터에게는 이 과정을 논리적으로 설명해줘야 합니다.
두 원소가 665가 되기위한 로직은 대충 이렇습니다.

1. 각 문자열의 첫 번째 문자가 동일하므로 두 번째 문자를 비교해야 한다. 하지만 6은 두 번째 문자가 없어 비교 대상이 없으므로 두번째 문자도 저기 자신인 6으로 하여 비교한다.
2. 65의 두번째 문자(5)와 6의 두번째 문자(6)를 비교한다. 6이 더 크므로 앞에 배치된다.
3. 따라서 [6,65]가 된다. 

이번에는 원소의 개수를 좀 늘려볼까요? [654, 65, 6, 5]
1. 각 문자열의 첫 번째 문자끼리 비교합니다. (6 = 6 = 6 > 5) 5는 가장 작으므로 맨 뒤에 배치되고 비교대상에서 제외됩니다. 
[?, ?, ?, 5]
2. 두 번째 문자끼리 비교합니다. 6은 두 번째 문자가 없으므로 두 번째 문자도 6으로 합니다. ( 5 = 5 = 6) 6이 가장 크므로 맨 앞에 배치하고 비교 대상에서 제외됩니다. 
[6, ?, ?, 5]
3. 세 번째 문자끼리 비교합니다. 65는 세 번째 문자가 없으므로 자기 자신인 65가 세 번째 문자가 되는데, 그러면 "6565"가 되는데 거기서 세번 째 문자인 6과 비교 대상인 "654"의 세 번째 문자인 4를 비교합니다. (6 > 4) 6이 더 크므로 65가 앞에 배치되고 654가 뒤에 배치됩니다.
[6, 65, 654, 5]

따라서 6656545가 결과로 나오고 이는 해당 조합으로 만들수 있는 가장 큰 수입니다.

이젠 이 로직을 코드로 구현해봅시다.
제한 조건에 리스트의 각 원소의 크기는 1000이하라고 나와 있으므로 세 번째 자리까지만 비교하면 됩니다. [654, 65, 6, 5]가 있을 때 [654, 6565, 666, 555]로 만들기만 하면 각 원소를 문자열로 변환하고 정렬만 해줘도 원하는 값을 얻을 수 있을 것입니다. 
이는 각 문자열을 *3 해준 것([654654654, 656565, 666, 555])을 기준으로 정렬을 수행해주기만 하면 됩니다.

"어? 그럼 만약 [65, 6]이 있으면 [656565, 666]으로 변환되는데 네 번째 문자를 비교할 때 666은 네 번째 문자가 없고 656565는 네 번째 문자가 5라서 65가 더 앞에 배치되는 거 아니야? 그럼 결과로 656이 출력되고 이건 틀린 결과잖아." 라고 생각하실 수 있는데, 애초에 네 번째 자릿수까지 비교하는 상황이 오려면 첫 번째, 두 번째, 세 번째 문자가 모두 동일한 경우에서만 가능하므로 이는 걱정할 필요가 없습니다.  
