# 백준 5639 - 이진 검색 트리

## 요구사항 분석

-   트리를 전위 순회(루트-왼쪽-오른쪽)한 결과가 주어졌을 때 트리를 후위 순회(왼쪽-오른쪽-루트)한 결과를 출력하시오.
-   어떤 노드 a를 루트노드로 하는 트리가 있을 때, 왼쪽 서브트리에 있는 모든 노드는 전부 a보다 작아야 하고 오른쪽 서브트리에 있는 모든 노드는 전부 a보다 커야 한다.
-   같은 키를 가지는 노드는 없다.

-   전위 순회한 결과 = (루트)(루트보다 작은 서브트리)(루트보다 큰 서브트리)
-   후위 순회한 결과 = (루트보다 작은 서브트리)(루트보다 큰 서브트리)(루트)

## 의사코드

### 첫 번째, 두 번째 시도에서 사용한 로직

-   전위 순회한 결과를 이진 트리로 만들기 $O(N^2)$ -> 시간초과

```
-   선택한 노드의 키가 현재 노드의 키보다 작은가?
    -   (yes) 왼쪽 노드
        -   왼쪽 노드가 이미 있는가?
            -   (yes) 선택한 노드의 키를 현재 노드의 키로 설정하고 다시 왼쪽 노드인지 오른쪽 노드인지 판별
            -   (no) 왼쪽 노드에 삽입
    -   (no) 오른쪽 노드
        -   오른쪽 노드가 이미 있는가?
            -   (yes) 선택한 노드의 키를 현재 노드의 키로 설정하고 다시 왼쪽 노드인지 오른쪽 노드인지 판별
            -   (no) 오른쪽 노드에 삽입
```

-   트리를 후위 순회한 결과 출력 $O(N)$

```
-   재귀 시작(현재 노드)
-   왼쪽 자식 노드가 있는가?
    -   (yes) 왼쪽 자식 노드를 현재 노드로 설정한 다음 다시 재귀 시작
-   오른쪽 자식 노드가 있는가?
    -   (yes) 오른쪽 자식 노드를 현재 노드로 설정한 다음 다시 재귀 시작
-   현재 노드로 설정되어 있는 노드 출력
```

### 세 번째 시도에서 사용한 로직

-   전위 순회한 결과를 이용해 곧바로 후위 순회한 결과 도출 $O(N)$ -> 틀렸습니다.
    트리를 생성하지 않고도 만들 수 있을까?

```
    * 스택의 최상위 요소(top)을 루트로 가정

    -   입력값이 top보다 작을 경우 (top의 왼쪽 서브트리인 경우)
        -   스택에 push
    -   입력값이 top보다 클 경우
        -   top-1이 없을 경우
            -   스택에 push (top의 오른쪽 서브트리)
        -   입력값이 top-1보다 작을 경우
            -   스택에 push (top의 오른쪽 서브트리)
        -   입력값이 top-1보다 클 경우
            -   입력값이 top-1보다 작아질 때까지 스택에서 pop
                또는
                top-1이 없을 때까지 스택에서 pop
    -   입력값이 더 이상 없을 경우 스택의 모든 요소 pop
```

### 네 번째 시도에서 사용한 로직

-   [참고한 블로그](https://gywlsp.github.io/boj/5639/)
-   전위 순회에서는 루트 노드를 가장 먼저 방문하고, 후위 순회에서는 루트 노드를 가장 마지막에 방문한다는 특징을 이용한다. $O(N)$ -> 정답입니다.
-   하나의 트리를 서브트리로 나누며, 루트 노드를 result 배열에 저장한다.
-   [자세한 풀이](https://velog.io/@ahhpc2012/%EB%B0%B1%EC%A4%80-5639-%EC%9D%B4%EC%A7%84-%EA%B2%80%EC%83%89-%ED%8A%B8%EB%A6%AC-Javascript)

## 시도

### 첫 번째 시도 (런타임 에러 (StackSizeExceeded))

-   원인: 재귀 함수로 인해 콜 스택이 꽉 차서 생긴 문제. node.js의 콜스택 최대 사이즈는 기본적으로 약 1만이기 때문에 에러가 발생한다.
-   변경: treeDown 함수를 재귀 함수에서 do...while문으로 변경

### 두 번째 시도 (시간초과)

-   원인: 10000개의 데이터가 한 방향으로만 들어날 경우 예를 들어 1부터 10000까지의 수가 차례대로 입력으로 들어올 경우. treeDown함수에서 입력값을 트리에 하나씩 추가할 때마다 트리의 깊이가 1씩 증가하고 깊이는 최대 10000까지 증가하며, do...while문은 매번 트리의 최대 깊이까지 들어간다.
    따라서 입력이 1...10000까지 차례대로 들어올 경우 프로그램 내에서 do...while문은 총 1부터 10000까지의 등차수열의 합만큼 수행된다. 등차수열의 합을 구하는 공식은 $\frac{10000(1+10000)}{2}$ 이므로 총 $50,005,000$번의 반복을 수행한다. 이를 빅오 표기법으로 표현하면 $O(N^2)$이 되므로 시간초과가 발생한다.

### 세 번째 시도 (틀렸습니다)

-   원인: 논리적으로 접근해서 로직을 구해야 하는데, 입력과 출력만 보고 끼워맞추기 식으로 로직을 작성한 것이 문제인 것 같다.
-   반례

    ```
    input:
    1
    2
    3
    4
    5

    correct output:
    5
    4
    3
    2
    1

    wrong output:
    2
    3
    4
    5
    1
    ```

### 네 번째 시도 (정답입니다)
